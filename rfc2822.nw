\title{RFC 2822 Message Parsing}

\chapter{Introduction}
RFC 2822 is the latest internet messaging standard 
that supercedes the traditional RFC 822.
This manual documents the implementation of a library 
for parsing and using RFC 2822 compliant messages.
It is implemented in Chez Scheme
and closely follows the organization of the RFC 
for easy navigation.

\chapter{Module Declaration and General Layout}
The implementation divides roughly into Datatype declarations, 
utilities that are not part of the RFC,
Tokenization, or low-level lexical parsing,
Field Parsing,
and Message Parsing. 
When an exported procedure is defined, 
an appropriate export chunk will accompany it.
When a procedure is used for the first time in this document,
an import chunk will import the appropriate libraries 
if they have not already been imported previously in the document.

<<rfc2822.sls>>=
<<License>>

(library (arcfide rfc2822)
	(export <<Exports>>)
	(import (rnrs base)
		<<Imports>>)

<<Datatypes>>

<<Utilities>>

<<Tokenization>>

<<Field Parsing>>

<<Message Parsing>>

<<Obsolete>>

)
@

Exported procedures will be documented in the following format:

\procsig{[[procedure-name]]}{\var{input-args} {\it\dots}}{\var{return-value}}

\chapter{Low-level Pre-processing and Tokenization}
RFC 2822 3.2 defines a series of lexical tokens 
which are used in later, higher-level parsers. 
These are used in structured field bodies. 
Higher level parsers are defined in terms of these lower-level tokens, 
and take streams of these tokens, rather than dealing explicitly 
with streams of characters.

\section{Character Classes (RFC 2822 3.2.1)}

<<Imports>>=
(srfi :14)
(riastradh parscheme)
@

The RFC defines a series of parsers for low level character classing. 
These may or may not be used by the future parsers, but are defined 
here just in case. 

{\it XXX: Decide whether these are actually needed.}

<<Tokenization>>=
(define-parser rfc2822-parser:no-ws-ctl
	(parser:char-in-set
		(char-set-union
			(ucs-range->char-set 1 8)
			(char-set (integer->char 11))
			(char-set (integer->char 12))
			(ucs-range->char-set 14 31)
			(char-set (integer->char 127)))))

(define-parser rfc2822-parser:text
	(parser:choice
		(parser:char-in-set
			(char-set-difference char-set:full (char-set #\return #\linefeed)))
		obs-text))

(define-parser rfc2822-parser:specials
	(parser:char-in-set
		(char-set #\( #\) #\< #\> #\[ #\] #\: #\; #\@ #\\ #\, #\. #\")))

@

\section{Quoted Characters (RFC 3.2.2)}
Quoted characters are characters that would normally not be valid 
except for their being escaped by a backslash character.

<<Tokenization>>=
(define-parser rfc2822-parser:quoted-pair
	(parser:choice 
		(parser:sequence (parser:char= #\\) rfc2822-parser:text)
		obs-qp))

@

\section{Whitespace and Comments (RFC 3.2.3)}
Whitespace and comments semantically have meaning 
no further than that of a single space. 
However, since a comment is usually intended 
for some human to read it, 
the following parsers will maintain the information in comments. 

These parsers return lists of strings and lists,
which contain the comment text.
If no comments were found, and only whitespace exists, 
then nil is returned.

The RFC doesn't give an explicit parser for CRLF and WSP, 
but this is useful.

<<Exports>>=
rfc2822-parser:crlf
@

<<Utilities>>=
(define-parser rfc2822-parser:crlf
	(parser:sequence 
		(parser:char= #\return)
		(parser:char= #\linefeed)))

(define-parser rfc2822-parser:wsp
	(parser:char-in-set (char-set #\space #\tab)))
	
(define-parser rfc2822-parser:alpha
	(parser:char-in-set char-set:letter))

(define-parser rfc2822-parser:digit
	(parser:char-in-set char-set:digit))

@

The RFC defines two main whitespace targets: FWS and CFWS.

<<Exports>>=
rfc2822-parser:cfws-opt
@

<<Imports>>=
(arcfide parser-util)
@

<<Tokenization>>=
(define-parser rfc2822-parser:fws
	(parser:deep-choice
		(*parser [s1 (parser:string:repeated rfc2822-parser:wsp)]
						 [rfc2822-parser:crlf]
						 [s2 (parser:string:at-least 1 rfc2822-parser:wsp)]
			(parser:return (string-append s1 s2)))
		(parser:string:at-least 1 rfc2822-parser:wsp)
		obs-fws))

(define %fws-opt (parser:optional #f rfc2822-parser:fws))

(define-parser rfc2822-parser:ctext
	(parser:char-in-set
		(char-set-difference char-set:full
			(char-set #\nul #\return #\linefeed #\tab #\space)
			(char-set #\( #\) #\\))))

(define-parser rfc2822-parser:ccontent
	(parser:string:at-least 1
		(parser:choice rfc2822-parser:ctext rfc2822-parser:quoted-pair)))

(define-parser rfc2822-parser:comment
	(parser:bracketed-list (parser:char= #\() (parser:char= #\))
		(parser:choice rfc2822-parser:comment
			(parser:string:append:repeated
				(parser:choice rfc2822-parser:fws rfc2822-parser:ccontent)))))

(define-parser rfc2822-parser:cfws
	(parser:sequence 
		(parser:list:repeated
			(parser:backtrackable 
				(parser:sequence %fws-opt rfc2822-parser:comment)))
		(parser:deep-choice
			(parser:sequence %fws-opt rfc2822-parser:comment)
			rfc2822-parser:fws)))

(define rfc2822-parser:cfws-opt (parser:optional #f rfc2822-parser:cfws))

@

\subsection{Obsolete Folding Whitespace (4.2)}

<<Obsolete>>=
(define-parser obs-fws
	(*parser [s1 (parser:string:at-least 1 rfc2822-parser:wsp)]
					 [rest (parser:string:repeated 
									 (parser:sequence
										 rfc2822-parser:crlf
										 (parser:string:at-least 1 rfc2822-parser:wsp)))]
		(parser:return (string-append s1 rest))))

@

\section{Atoms (RFC 3.2.4)}
Atoms are just small units of basic text without controls, wsp, or specials.
The RFC defines a dot atom production for times when runs of atoms may have 
a period between them.
Atoms are returned as strings.

<<Imports>>=
(rnrs lists)
@

<<Tokenization>>=
(define-parser rfc2822-parser:atext
	(parser:char-in-set
		(char-set-difference char-set:full
			char-set:iso-control
			char-set:whitespace
			(char-set #\nul #\( #\) #\< #\> #\[ #\] #\: #\; #\@ #\\ #\, #\. #\"))))

(define-parser %1*atext
	(parser:string:at-least 1 rfc2822-parser:atext))

(define-parser rfc2822-parser:atom
	(parser:single-bracketed rfc2822-parser:cfws-opt %1*atext))

(define-parser rfc2822-parser:dot-atom-text
	(*parser [s1 %1*atext]
					 [rest (parser:list:repeated
									 (parser:sequence (parser:char= #\.) %1*atext))]
		(parser:return 
			(fold-left (lambda (x y) (string-append x "." y)) s1 rest))))

(define-parser rfc2822-parser:dot-atom
	(parser:single-bracketed rfc2822-parser:cfws-opt rfc2822-parser:dot-atom-text))

@

\section{Quoted Strings (RFC 3.2.5)}
Quoted strings allows a stream of text to be considered as one unit, 
such as when this text can not be expressed with just the atom syntax. 
A Quoted String can be folded, and is treated as a single unit 
modulo quote characters and surrounding CWFS.

<<Exports>>=
rfc2822-parser:quoted-string
@

<<Tokenization>>=
(define-parser rfc2822-parser:qtext
	(parser:char-in-set
		(char-set-difference char-set:full
			(char-set #\nul #\return #\linefeed #\tab #\space #\\ #\"))))

(define-parser rfc2822-parser:qcontent
	(parser:string:at-least 1
		(parser:choice rfc2822-parser:qtext rfc2822-parser:quoted-pair)))

(define-parser rfc2822-parser:quoted-string
	(parser:bracketed
		(parser:sequence rfc2822-parser:cfws-opt (parser:char= #\"))
		(parser:sequence (parser:char= #\") rfc2822-parser:cfws-opt)
		(parser:string:append:repeated
			(parser:choice rfc2822-parser:fws rfc2822-parser:qcontent))))

@

\section{Miscellaneous Tokens (RFC 3.2.6)}
As well as providing convenience parsers defined in the RFC for handling 
runs of quoted strings and atoms. 

<<Tokenization>>=
(define-parser rfc2822-parser:word
	(parser:deep-choice rfc2822-parser:atom rfc2822-parser:quoted-string))
	
(define-parser rfc2822-parser:phrase
	(parser:deep-choice
		(parser:list:at-least 1 rfc2822-parser:word)
		obs-phrase))

@

It is also necessary to parse unstructured fields, 
which do not have the same tokenization as above.
In particular, white space and comments are not collapsed. 

<<Exports>>=
rfc2822-parser:unstructured
@

<<Tokenization>>=
(define-parser rfc2822-parser:utext
	(parser:choice 
		(parser:char-in-set
			(char-set-difference char-set:full
				(char-set #\nul #\return #\linefeed #\tab #\space)))
		obs-utext))

#;(define-parser rfc2822-parser:unstructured
	(parser:string:at-least-until 1
		(parser:choice (parser:peek rfc2822-parser:crlf) (parser:end))
		rfc2822-parser:utext))

(define-parser rfc2822-parser:unstructured
	(parser:string:append:repeated-until
		(parser:deep-choice 
			(parser:peek 
				(parser:sequence 
					rfc2822-parser:crlf 
					(parser:choice 
						(parser:end) 
						(parser:char-not-in-set char-set:whitespace))))
			(parser:end))
		(parser:deep-choice 
			rfc2822-parser:fws
			(parser:string:at-least-until 1
				(parser:choice (parser:peek rfc2822-parser:crlf) (parser:end))
				rfc2822-parser:utext))))

@

\section{Obsolete Tokens (4.1)}

<<Obsolete>>=
(define-parser obs-qp
	(parser:sequence (parser:char= #\\)
		(parser:char-in-set char-set:full)))

(define-parser obs-text 
	(parser:char-in-set char-set:full))

(define-parser obs-utext obs-text)

(define-parser obs-phrase
	(*parser [w rfc2822-parser:word]
					 [rest (parser:string:append:repeated
									 (parser:choice 
										 rfc2822-parser:word
										 (parser:string= ".")
										 rfc2822-parser:cfws))]
		(parser:return (string-append w rest))))
		
(define-parser obs-phrase-list
	(parser:deep-choice
		(*parser [lst (parser:list:at-least 1
										(*parser [p (parser:optional #f 
																	rfc2822-parser:phrase)]
														 [rfc2822-parser:cfws-opt]
														 [(parser:char= #\,)]
														 [rfc2822-parser:cfws-opt]
											(parser:return p)))]
						 [last (parser:optional #f rfc2822-parser:phrase)]
			(parser:return
				(filter (lambda (x) x)
					(append lst (list last)))))
		rfc2822-parser:phrase))

@


\chapter{Date and Time Specification (RFC 3.3)}
This following parsers handle the RFC's definition of date and time, 
and return the date and time object as a date object in Chez Scheme. 
There is little validation occuring in this specification other than 
what is necessary to parser the field. 
As such, it does not do simple checking like assuring that the 
numeric day of the month corresponds to the day of the week given, 
\&c.

<<Imports>>=
(only (scheme) 
	make-date
	date-second date-hour date-minute date-day date-month date-year
	date-zone-offset)
@

<<Exports>>=
rfc2822-parser:date-time
@

<<Field Parsing>>=
(define-parser rfc2822-parser:date-time
	(*parser [(parser:optional #f 
							(parser:sequence 
								rfc2822-parser:day-of-week
								(parser:char= #\,)))]
					 [date rfc2822-parser:date]
					 [rfc2822-parser:fws]
					 [time rfc2822-parser:time]
					 [rfc2822-parser:cfws-opt]
		(parser:return 
			(make-date 0
				(date-second time)
				(date-minute time)
				(date-hour time)
				(date-day date)
				(date-month date)
				(date-year date)
				(date-zone-offset time)))))

(define-parser rfc2822-parser:day-of-week
	(parser:deep-choice
		(parser:sequence %fws-opt rfc2822-parser:day-name)
		obs-day-of-week))

(define-parser rfc2822-parser:day-name
	(parser:deep-choice
		(parser:string-ci= "mon")
		(parser:string-ci= "tue")
		(parser:string-ci= "wed")
		(parser:string-ci= "thu")
		(parser:string-ci= "fri")
		(parser:string-ci= "sat")
		(parser:string-ci= "sun")))
		
(define-parser rfc2822-parser:date
	(*parser [day rfc2822-parser:day]
					 [month rfc2822-parser:month]
					 [year rfc2822-parser:year]
		(parser:return
			(make-date 0 0 0 0 day month year 0))))
			
(define-parser rfc2822-parser:year
	(parser:deep-choice parser-4*digit obs-year))

(define-parser rfc2822-parser:month
	(parser:deep-choice
		(parser:single-bracketed rfc2822-parser:fws 
			(*parser [name rfc2822-parser:month-name]
				(parser:return
					(case (string->symbol name)
						[(jan) 1]
						[(feb) 2]
						[(mar) 3]
						[(apr) 4]
						[(may) 5]
						[(jun) 6]
						[(jul) 7]
						[(aug) 8]
						[(sep) 9]
						[(oct) 10]
						[(nov) 11]
						[(dec) 12]))))
		obs-month))
	 
(define-parser rfc2822-parser:month-name
	(parser:deep-choice
		(parser:string-ci= "jan")
		(parser:string-ci= "feb")
		(parser:string-ci= "mar")
		(parser:string-ci= "apr")
		(parser:string-ci= "may")
		(parser:string-ci= "jun")
		(parser:string-ci= "jul")
		(parser:string-ci= "aug")
		(parser:string-ci= "sep")
		(parser:string-ci= "oct")
		(parser:string-ci= "nov")
		(parser:string-ci= "dec")))

(define-parser rfc2822-parser:day
	(parser:deep-choice
		(parser:sequence %fws-opt parser-1*2digit)
		obs-day))

(define-parser rfc2822-parser:time
	(*parser [time rfc2822-parser:time-of-day]
					 [rfc2822-parser:fws]
					 [zone rfc2822-parser:zone]
		(parser:return
			(make-date 0
				(date-second time)
				(date-minute time)
				(date-hour time)
				1 1 1901
				zone))))
		
(define-parser rfc2822-parser:time-of-day
	(*parser [hour rfc2822-parser:hour]
					 [(parser:char= #\:)]
					 [minute rfc2822-parser:minute]
					 [second (parser:optional 0 
										 (parser:sequence 
											 (parser:char= #\:) 
											 rfc2822-parser:second))]
		(parser:return
			(make-date 0 second minute hour
				1 1 1901 0))))

(define-parser rfc2822-parser:hour
	(parser:deep-choice parser-2digit obs-hour))
(define-parser rfc2822-parser:minute
	(parser:deep-choice parser-2digit obs-minute))
(define-parser rfc2822-parser:second
	(parser:deep-choice parser-2digit obs-second))

(define-parser rfc2822-parser:zone
	(parser:deep-choice 
		(*parser [sign (parser:choice 
										 (parser:sequence  
											 (parser:char= #\+) 
											 (parser:return +))
										 (parser:sequence 
											 (parser:char= #\-) 
											 (parser:return -)))]
						 [offset parser-4digit]
			(parser:return (sign offset)))
		obs-zone))

@

The following are some simple parsers for digits 
that return the digits converted from their strings into numbers.

<<Field Parsing>>=
(define-parser parser-1*2digit (parser:string-number:between 1 2))
(define-parser parser-4*digit (parser:string-number:at-least 4))
(define-parser parser-4digit (parser:string-number:exactly 4))
(define-parser parser-2digit (parser:string-number:exactly 2))

@

\section{Obsolete Time Formats (4.3)}

The following parsers parse formats that are marked as obsolete 
and must not be generated by compliant programs,
but compliant programs must still be able to parse them. 

<<Obsolete>>=
(define-parser obs-day-of-week
	(parser:single-bracketed rfc2822-parser:cfws-opt rfc2822-parser:day-name))

(define-parser obs-year
	(parser:single-bracketed rfc2822-parser:cfws-opt
		(parser:string-number:at-least 2)))

(define-parser obs-month
	(parser:single-bracketed rfc2822-parser:cfws
		rfc2822-parser:month-name))

(define-parser obs-day
	(parser:single-bracketed rfc2822-parser:cfws-opt parser-1*2digit))

(define-parser obs-hour
	(parser:single-bracketed rfc2822-parser:cfws-opt parser-2digit))

(define-parser obs-minute
	(parser:single-bracketed rfc2822-parser:cfws-opt parser-2digit))

(define-parser obs-second
	(parser:single-bracketed rfc2822-parser:cfws-opt parser-2digit))
	
@

Note that when parsing time zones, 
the RFC states that military times should all 
be treated as GMT unless there is out of band information 
to suggest treating them differently. 
While this is strange, 
I do this here to follow with the standard, 
since there is no way at present to determine 
how to treat the military time.

<<Obsolete>>=
(define-parser obs-zone
	(parser:deep-choice
		(zone-parser 0 "UT" "GMT")
		(zone-parser -4 "EDT")
		(zone-parser -5 "EST" "CDT")
		(zone-parser -6 "CST" "MDT")
		(zone-parser -7 "MST" "PDT")
		(zone-parser -8 "PST")
		(parser:sequence 
			(parser:char-in-set char-set:letter)
			(parser:return 0))))

(define (zone-parser offset . values)
	(parser:sequence
		(apply parser:deep-choice
			(map parser:string-ci= values))
		(parser:return offset)))

@

\chapter{Address Specification (RFC 3.4)}

Addresses are either individual mailboxes or groups thereof.

<<Imports>>=
(rnrs records syntactic)
@

<<Exports>>=
rfc2822-parser:address
@

<<Datatypes>>=
(define-record-type rfc2822-address (fields name local domain))
(define-record-type rfc2822-group (fields name addresses))
@

<<Field Parsing>>=
(define-parser rfc2822-parser:address
	(parser:deep-choice rfc2822-parser:mailbox rfc2822-parser:group))

@

Mailboxes are either regular address specifications or named 
specifications.

<<Field Parsing>>=
(define-parser rfc2822-parser:mailbox
	(parser:deep-choice rfc2822-parser:name-addr rfc2822-parser:addr-spec))

@

Named addresses are angled addresses prepended by an optional display name.

<<Field Parsing>>=
(define-parser rfc2822-parser:name-addr
	(*parser [name (parser:optional #f rfc2822-parser:display-name)]
					 [addr rfc2822-parser:angle-addr]
		(parser:return
			(make-rfc2822-address name
				(rfc2822-address-local addr)
				(rfc2822-address-domain addr)))))

@

An angle address is just an angle delimited address specification.

<<Field Parsing>>=
(define-parser rfc2822-parser:angle-addr
	(parser:deep-choice
		(parser:bracketed
			(parser:sequence rfc2822-parser:cfws-opt (parser:char= #\<))
			(parser:sequence (parser:char= #\>) rfc2822-parser:cfws-opt)
			rfc2822-parser:addr-spec)
		obs-angle-addr))

@

Groups are named lists of addresses. They may have no addresses 
at all.

<<Field Parsing>>=
(define-parser rfc2822-parser:group
	(*parser [name rfc2822-parser:display-name]
					 [(parser:char= #\:)]
					 [mailbox-list
						(parser:optional #f
							(parser:deep-choice 
								rfc2822-parser:mailbox-list
								rfc2822-parser:cfws))]
					 [(parser:char= #\;)]
					 [rfc2822-parser:cfws-opt]
		(parser:return
			(make-rfc2822-group name mailbox-list))))

@

Display names are phrases.

<<Field Parsing>>=
(define-parser rfc2822-parser:display-name rfc2822-parser:phrase)

@

Mailbox lists and address lists are comma separated mailboxes.

<<Field Parsing>>=
(define-parser rfc2822-parser:mailbox-list
	(parser:deep-choice
		(*parser [first rfc2822-parser:mailbox]
						 [rest (parser:list:repeated
										 (parser:sequence 
											 (parser:char= #\,) 
											 rfc2822-parser:mailbox))]
			(parser:return (cons first rest)))
		obs-mbox-list))

(define-parser rfc2822-parser:address-list
	(parser:deep-choice
		(*parser [first rfc2822-parser:address]
						 [rest (parser:list:repeated
										 (parser:sequence 
											 (parser:char= #\,) 
											 rfc2822-parser:address))]
			(parser:return (cons first rest)))
		obs-addr-list))

@

An address specification consistes of a local and a domain part.

<<Field Parsing>>=
(define-parser rfc2822-parser:addr-spec
	(*parser [local rfc2822-parser:local-part]
					 [(parser:char= #\@)]
					 [domain rfc2822-parser:domain]
		 (parser:return
			 (make-rfc2822-address #f local domain))))

@

Local parts are either atoms with dots or quoted strings.

<<Field Parsing>>=
(define-parser rfc2822-parser:local-part
	(parser:deep-choice 
		rfc2822-parser:quoted-string 
		rfc2822-parser:dot-atom
		obs-local-part))

@

Domains use the possible domain literal.

<<Field Parsing>>=
(define-parser rfc2822-parser:domain
	(parser:deep-choice
		rfc2822-parser:dot-atom
		rfc2822-parser:domain-literal
		obs-domain))

@

A domain literal specifies an actual, specific host.

<<Datatypes>>=
(define-record-type rfc2822-domain-literal (fields value))
@

<<Field Parsing>>=
(define-parser rfc2822-parser:domain-literal
	(*parser 
		[res 
		 (parser:bracketed
			 (parser:sequence rfc2822-parser:cfws-opt (parser:char= #\[))
			 (parser:sequence (parser:char= #\]) rfc2822-parser:cfws-opt)
			 (parser:string:append:repeated
				 (parser:single-bracketed %fws-opt rfc2822-parser:dcontent)))]
		(parser:return (make-rfc2822-domain-literal res))))

@

We handle quotes in dcontent.

<<Field Parsing>>=
(define-parser rfc2822-parser:dcontent
	(parser:string:at-least 1
		(parser:choice rfc2822-parser:dtext rfc2822-parser:quoted-pair)))

(define-parser rfc2822-parser:dtext
	(parser:char-in-set
		(char-set-difference char-set:full
			char-set:whitespace
			(char-set #\[ #\] #\\))))

@

\section{Obsolete Address Parsers}

This section details the obsolete parsers that 
parse the obsolete syntax as required by RFC 2822.

Firstly, we make an obslete address structure that 
is a child of the regular address structure. 
It adds a route, which only exists in the old style. 

<<Datatypes>>=
(define-record-type rfc2822-obsolete-address
	(parent rfc2822-address)
	(fields route))
@

<<Obsolete>>=
(define-parser obs-angle-addr
	(parser:bracketed
		(parser:sequence rfc2822-parser:cfws-opt (parser:char= #\<))
		(parser:sequence (parser:char= #\>) rfc2822-parser:cfws-opt)
		(*parser [route (parser:optional #f obs-route)]
						 [addr rfc2822-parser:addr-spec]
			(parser:return
				(if route
						(make-rfc2822-obsolete-address
							#f
							(rfc2822-address-local addr)
							(rfc2822-address-domain addr)
							route)
						addr)))))

(define-parser obs-route
	(parser:bracketed
		rfc2822-parser:cfws-opt
		(parser:sequence (parser:char= #\:) rfc2822-parser:cfws-opt)
		obs-domain-list))

(define-parser obs-domain-list
	(parser:list:at-least 1
		(parser:sequence
			(parser:repeated (lambda (x y) x) (parser:epsilon)
				(parser:choice (parser:char= #\,) rfc2822-parser:cfws))
			(parser:char= #\@)
			rfc2822-parser:domain)))

(define-parser obs-mbox-list
	(*parser [lst (parser:list:at-least 1
									(*parser [box (parser:optional #f 
																	rfc2822-parser:mailbox)]
													 [rfc2822-parser:cfws-opt]
													 [(parser:char= #\,)]
													 [rfc2822-parser:cfws-opt]
										(parser:return box)))]
					 [last (parser:optional #f rfc2822-parser:mailbox)]
		(parser:return 
			(filter (lambda (x) x) 
				(append lst (list last))))))

(define-parser obs-addr-list
	(*parser [lst (parser:list:at-least 1
									(*parser [box (parser:optional #f 
																	rfc2822-parser:address)]
													 [rfc2822-parser:cfws-opt]
													 [(parser:char= #\,)]
													 [rfc2822-parser:cfws-opt]
										(parser:return box)))]
					 [last (parser:optional #f rfc2822-parser:address)]
		(parser:return 
			(filter (lambda (x) x) 
				(append lst (list last))))))

(define-parser obs-local-part
	(*parser [first rfc2822-parser:word]
					 [rest (parser:string:append:repeated
									 (*parser [(parser:char= #\.)]
														[v rfc2822-parser:word]
										 (parser:return (string-append "." v))))]
		(parser:return (string-append first rest))))

(define-parser obs-domain
	(*parser [first rfc2822-parser:atom]
					 [rest (parser:string:append:repeated
									 (*parser [(parser:char= #\.)]
														[v rfc2822-parser:atom]
										 (parser:return (string-append "." v))))]
		(parser:return (string-append first rest))))

@

\chapter{Message Parsers (3.5)}

<<Exports>>=
rfc2822-parser:message
rfc2822-parser:body
@

<<Datatypes>>=
(define-record-type rfc2822-message (fields fields body))
@

<<Message Parsing>>=
(define-parser rfc2822-parser:message
	(*parser [fields (parser:deep-choice 
										 rfc2822-parser:fields
										 obs-fields)]
					 [body (parser:optional #f rfc2822-parser:body)]
		(parser:return
			(make-rfc2822-message fields body))))

(define-parser rfc2822-parser:body
	(parser:string:append:repeated
		(parser:sequence rfc2822-parser:crlf 
			(parser:string:repeated rfc2822-parser:text))))

@

\chapter{Field Definitions (3.6)}

<<Exports>>=
rfc2822-parser:fields rfc2822-parser:field
@

Parsing the fields does no error checking of the order or type of fields
that exist.  Validating whether a given field list is a valid RFC 2822
message header is left to another procedure.  Please note that we also
deviate from the RFC in that we don't distinguish between the obsolete
field style here. Instead we read in the entire set of fields without
checking whether the trace fields come first. Since this is just parsing,
we can do this.

<<Field Parsing>>=
(define-parser rfc2822-parser:fields
	(parser:list:repeated rfc2822-parser:field))

(define-parser rfc2822-parser:field
  (parser:deep-choice
		rfc2822-parser:return
		rfc2822-parser:received
    rfc2822-parser:resent-date
		rfc2822-parser:resent-from
		rfc2822-parser:resent-sender
		rfc2822-parser:resent-to
		rfc2822-parser:resent-cc
		rfc2822-parser:resent-bcc
		rfc2822-parser:resent-msg-id
		rfc2822-parser:orig-date
		rfc2822-parser:from
		rfc2822-parser:sender
		rfc2822-parser:reply-to
		rfc2822-parser:to
		rfc2822-parser:cc
		rfc2822-parser:bcc
		rfc2822-parser:message-id
		rfc2822-parser:in-reply-to
		rfc2822-parser:references
		rfc2822-parser:subject
		rfc2822-parser:comments
		rfc2822-parser:keywords
		rfc2822-parser:optional-field))
		
@

\section{Validating Messages}

Validating messages requires that we also validate the field counts.
These are too complicated to do during normal parsing without 
confusing the code. We may also wish to ignore this validation 
for some reason. Regardless, we provide 
[[validate-rfc2822-field-counts]] to raise an assertion violation 
error if the message is not valid.

<<Imports>>=
(rnrs enums)
(riastradh foof-loop)
(rnrs control)
@

<<Message Parsing>>=
(define (validate-rfc2822-field-counts fields)
	(define field-names
		'(orig-date from sender reply-to to cc bcc message-id 
			in-reply-to references subject comments
			keywords optional-field))
	(define field-index
		(enum-set-indexer (make-enumeration field-names)))
	(define field-counts (make-vector (length field-names) 0))
	(define (field-count field)
		(vector-ref field-counts (field-index field)))
	(define (field-inc! field)
		(when (memq field field-names)
			(let ([i (field-index field)])
				(vector-set! field-counts i (+ 1 (field-count field))))))
	(define multiple-from? #f)
	(define non-trace-fields
		(loop ([for field rest (in-list fields)]
					 [while (eq? 'trace (car field))])
			=> (cdr rest)))
	(loop ([for field (in-list non-trace-fields)])
		(case (car field)
			[(from)
			 (when (null? (cdr field))
				 (set! multiple-from? #t))]
			[(trace) 
			 (assertion-violation 'validate-rfc2822-field-counts
				 "Trace field occurs after regular fields.")]
			[else (field-inc! (car field))])
		(field-inc! (car field)))
	(assert (= 1 (field-count 'orig-date)))
	(assert (= 1 (field-count 'from)))
	(assert (if multiple-from? 
							(= 1 (field-count 'sender))
							(<= 0 (field-count 'sender) 1)))
	(assert
		(for-all (lambda (x) (<= 0 (field-count x) 1))
			'(reply-to to cc bcc message-id in-reply-to 
				references subject))))

@

\section{Obsolete Message Fields (4.5)}

When parsing fields in the obsolete style, 
there is no requirement to block traces together 
with other code. 
This leaves a lot of unspecified behavior. 
If the message fields come from an obsolete style, 
then we just add a special field [[X-Obsolete-Headers]]
to let them know that they have to do things the harder way.

{\it XXX: There ought to be a better way to do this.}

<<Obsolete>>=
(define-parser obs-fields
	(parser:list:repeated
		(parser:deep-choice
			obs-return
			obs-received
			obs-orig-date
			obs-from
			obs-sender
			obs-reply-to
			obs-to
			obs-cc
			obs-bcc
			obs-message-id
			obs-in-reply-to
			obs-references
			obs-subject
			obs-comments
			obs-keywords
			obs-resent-date
			obs-resent-from
			obs-resent-send
			obs-resent-reply
			obs-resent-to
			obs-resent-cc
			obs-resent-bcc
			obs-resent-mid
			obs-optional)))

@

\section{Field Parser Conveniences}

The next sections deal with the actual field definitions. 
The following is a convenience parser for fields.

<<Exports>>=
parser:rfc2822-header
@

<<Utilities>>=
(define (parser:rfc2822-header name head-str parser)
	(*parser [(parser:string-ci= head-str)]
					 [(parser:char= #\:)]
					 [res parser]
					 [rfc2822-parser:crlf]
		(parser:return
			(cons name res))))
			
(define (parser:obs-header name field parser)
	(*parser [(parser:string-ci= field)]
					 [(parser:string:repeated rfc2822-parser:wsp)]
					 [(parser:char= #\:)]
					 [res parser]
					 [rfc2822-parser:crlf]
		(parser:return (cons name res))))

@

\section{Origination date field (3.6.1)}

<<Field Parsing>>=
(define-parser rfc2822-parser:orig-date
	(parser:rfc2822-header 'orig-date "Date" rfc2822-parser:date-time))

@

\subsection{Obsolete Origination Date Field (4.5.1)}

<<Obsolete>>=
(define-parser obs-orig-date
	(parser:obs-header 'orig-date "Date" rfc2822-parser:date-time))

@

\section{Originator Fields (3.6.2)}

<<Field Parsing>>=
(define-parser rfc2822-parser:from
	(parser:rfc2822-header 'from "From" rfc2822-parser:mailbox-list))

(define-parser rfc2822-parser:sender
	(parser:rfc2822-header 'sender "Sender" rfc2822-parser:mailbox))

(define-parser rfc2822-parser:reply-to
	(parser:rfc2822-header 'reply-to "Reply-To" 
		rfc2822-parser:address-list))

@

\subsection{Obsolete Originator Fields (4.5.2)}

<<Obsolete>>=
(define-parser obs-from
	(parser:obs-header 'from "From" rfc2822-parser:mailbox-list))

(define-parser obs-sender
	(parser:obs-header 'sender "Sender" rfc2822-parser:mailbox))

(define-parser obs-reply-to
	(parser:obs-header 'reply-to "Reply-To" 
		rfc2822-parser:mailbox-list))

@


\section{Destination Address Fields (3.6.3)}

<<Field Parsing>>=
(define-parser rfc2822-parser:to
	(parser:rfc2822-header 'to "To" rfc2822-parser:address-list))

(define-parser rfc2822-parser:cc
	(parser:rfc2822-header 'cc "Cc" rfc2822-parser:address-list))
	
(define-parser rfc2822-parser:bcc
	(parser:rfc2822-header 'bcc "Bcc"
		(parser:deep-choice rfc2822-parser:address-list rfc2822-parser:cfws-opt)))

@

\subsection{Obsolete Destination Address Fields (4.5.2)}

<<Obsolete>>=
(define-parser obs-to
	(parser:obs-header 'to "To" rfc2822-parser:address-list))

(define-parser obs-cc
	(parser:obs-header 'cc "Cc" rfc2822-parser:address-list))
	
(define-parser obs-bcc
	(parser:obs-header 'bcc "Bcc"
		(parser:deep-choice rfc2822-parser:address-list rfc2822-parser:cfws-opt)))

@

\section{Identification Fields (3.6.4)}

<<Exports>>=
rfc2822-parser:msg-id
@

<<Field Parsing>>=
(define-parser rfc2822-parser:message-id
	(parser:rfc2822-header 'message-id "Message-ID" 
		rfc2822-parser:msg-id))

(define-parser rfc2822-parser:in-reply-to
	(parser:rfc2822-header 'in-reply-to "In-Reply-To"
		(parser:list:at-least 1 rfc2822-parser:msg-id)))

(define-parser rfc2822-parser:references
	(parser:rfc2822-header 'references "References"
		(parser:list:at-least 1 rfc2822-parser:msg-id)))

(define-parser rfc2822-parser:msg-id
	(parser:bracketed
		(parser:sequence rfc2822-parser:cfws-opt (parser:char= #\<))
		(parser:sequence (parser:char= #\>) rfc2822-parser:cfws-opt)
		(*parser [left id-left]
						 [(parser:char= #\@)]
						 [right id-right]
			(parser:return
				(string-append left "@" right)))))

(define-parser id-left
	(parser:deep-choice
		rfc2822-parser:dot-atom-text
		rfc2822-parser:no-fold-quote
		obs-id-left))

(define-parser id-right
	(parser:deep-choice
		rfc2822-parser:dot-atom-text
		rfc2822-parser:no-fold-literal
		obs-id-right))

(define-parser rfc2822-parser:no-fold-quote
	(parser:single-bracketed (parser:char= #\")
		(parser:string:repeated
			(parser:choice 
				rfc2822-parser:qtext 
				rfc2822-parser:quoted-pair))))

(define-parser rfc2822-parser:no-fold-literal
	(parser:bracketed
		(parser:char= #\[)
		(parser:char= #\])
		(parser:string:repeated
			rfc2822-parser:dtext
			rfc2822-parser:quoted-pair)))

@

\subsection{Obsolete Identification Field (4.5.4)}

<<Obsolete>>=
(define-parser obs-message-id
	(parser:obs-header 'message-id "Message-ID"
		rfc2822-parser:msg-id))

(define-parser obs-in-reply-to
	(parser:obs-header 'in-reply-to "In-Reply-To"
		(parser:list:repeated
			(parser:deep-choice
				rfc2822-parser:phrase
				rfc2822-parser:msg-id))))

(define-parser obs-references
	(parser:obs-header 'references "References"
		(parser:list:repeated
			(parser:deep-choice
				rfc2822-parser:phrase
				rfc2822-parser:msg-id))))

(define-parser obs-id-left rfc2822-parser:local-part)
(define-parser obs-id-right rfc2822-parser:domain)

@

\section{Information Fields (3.6.5)}

<<Field Parsing>>=
(define-parser rfc2822-parser:subject
	(parser:rfc2822-header 'subject "Subject" 
		rfc2822-parser:unstructured))

(define-parser rfc2822-parser:comments
	(parser:rfc2822-header 'comments "Comments"
		rfc2822-parser:unstructured))

(define-parser rfc2822-parser:keywords
	(parser:rfc2822-header 'keywords "Keywords"
		(*parser [first rfc2822-parser:phrase]
						 [rest (parser:list:repeated
										 (parser:sequence (parser:char= #\,)
											 rfc2822-parser:phrase))]
			(parser:return (cons first rest)))))

@

\subsection{Obsolete Information Fields (4.5.5)}

<<Obsolete>>=
(define-parser obs-subject
	(parser:obs-header 'subject "Subject"
		rfc2822-parser:unstructured))

(define-parser obs-comments
	(parser:obs-header 'comments "Comments"
		rfc2822-parser:unstructured))

(define-parser obs-keywords
	(parser:obs-header 'keywords "Keywords" obs-phrase-list))

@

\section{Resent Fields (3.6.6)}

<<Field Parsing>>=
(define-parser rfc2822-parser:resent-date
	(parser:rfc2822-header 'resent-date "Resent-Date"
		rfc2822-parser:date-time))

(define-parser rfc2822-parser:resent-from
	(parser:rfc2822-header 'resent-from "Resent-From"
		rfc2822-parser:mailbox-list))

(define-parser rfc2822-parser:resent-sender
	(parser:rfc2822-header 'resent-sender "Resent-Sender"
		rfc2822-parser:mailbox))

(define-parser rfc2822-parser:resent-to
	(parser:rfc2822-header 'resent-to "Resent-To"
		rfc2822-parser:address-list))

(define-parser rfc2822-parser:resent-cc
	(parser:rfc2822-header 'resent-cc "Resent-Cc"
		rfc2822-parser:address-list))

(define-parser rfc2822-parser:resent-bcc
	(parser:rfc2822-header 'resent-bcc "Resent-Bcc"
		(parser:deep-choice rfc2822-parser:address-list rfc2822-parser:cfws-opt)))

(define-parser rfc2822-parser:resent-msg-id
	(parser:rfc2822-header 'resent-msg-id "Resent-Msg-ID"
		rfc2822-parser:msg-id))

@

\subsection{Obsolete Resent Fields (4.5.6)}

<<Obsolete>>=
(define-parser obs-resent-date
	(parser:obs-header 'resent-date "Resent-Date"
		rfc2822-parser:date-time))

(define-parser obs-resent-from
	(parser:obs-header 'resent-from "Resent-From"
		rfc2822-parser:mailbox-list))

(define-parser obs-resent-send
	(parser:obs-header 'resent-sender "Resent-Sender"
		rfc2822-parser:mailbox))

(define-parser obs-resent-to
	(parser:obs-header 'resent-to "Resent-To"
		rfc2822-parser:address-list))

(define-parser obs-resent-cc
	(parser:obs-header 'resent-cc "Resent-Cc"
		rfc2822-parser:address-list))

(define-parser obs-resent-bcc
	(parser:obs-header 'resent-bcc "Resent-Bcc"
		(parser:deep-choice rfc2822-parser:address-list rfc2822-parser:cfws-opt)))

(define-parser obs-resent-mid
	(parser:obs-header 'resent-msg-id "Resent-Msg-ID"
		rfc2822-parser:msg-id))
		
(define-parser obs-resent-reply
	(parser:obs-header 'resent-reply-to "Resent-Reply-To"
		rfc2822-parser:address-list))

@

\section{Trace Fields (3.6.7)}

Note that we stray from the RFC slightly here to simplify 
the parsing. We just provide the field parsers, rather than 
a general parser for trace fields that would presumably 
return some sort of structure related to it.

<<Field Parsing>>=
(define-parser rfc2822-parser:return
  (parser:rfc2822-header 'return-path "Return-Path" rfc2822-parser:path))

(define-parser rfc2822-parser:path
	(parser:deep-choice
		(parser:bracketed
			(parser:sequence rfc2822-parser:cfws-opt (parser:char= #\<))
			(parser:sequence (parser:char= #\>) rfc2822-parser:cfws-opt)
			(parser:deep-choice
				rfc2822-parser:addr-spec
				rfc2822-parser:cfws-opt))
		obs-path))

@

To handle parsing the received field, 
we provide an additional structure.

<<Datatypes>>=
(define-record-type rfc2822-received (fields entries date))
@

<<Field Parsing>>=
(define-parser rfc2822-parser:received
	(parser:rfc2822-header 'received "Received"
		(*parser
				[entries rfc2822-parser:name-val-list]
				[rfc2822-parser:cfws-opt]
				[(parser:char= #\;)]
				[date rfc2822-parser:date-time]
			(parser:return (make-rfc2822-received entries date)))))

(define-parser rfc2822-parser:name-val-list
	(parser:list:repeated
		(parser:sequence rfc2822-parser:cfws-opt rfc2822-parser:name-val-pair)))

(define-parser rfc2822-parser:name-val-pair
	(*parser 
			[name rfc2822-parser:item-name]
			[rfc2822-parser:cfws]
			[value rfc2822-parser:item-value]
		(parser:return (cons name value))))

(define-parser rfc2822-parser:item-name
	(*parser 
			[first-char rfc2822-parser:alpha]
			[rest 
				(parser:string:repeated
					(parser:choice 
						(parser:char= #\-)
						rfc2822-parser:alpha
						rfc2822-parser:digit))]
		(parser:return (string-append (string first-char) rest))))

(define-parser rfc2822-parser:item-value
	(parser:deep-choice
		(parser:list:at-least 1 rfc2822-parser:angle-addr)
		rfc2822-parser:addr-spec
		rfc2822-parser:msg-id
		rfc2822-parser:domain
		rfc2822-parser:atom))

@

\subsection{Obsolete Trace Fields (4.5.7)}

<<Obsolete>>=
(define-parser obs-return
	(parser:obs-header 'return-path "Return-Path"
		rfc2822-parser:path))

(define-parser obs-received
	(parser:obs-header 'received "Received"
		rfc2822-parser:name-val-list))

(define-parser obs-path obs-angle-addr)

@

\section{Optional Fields (3.6.8)}

<<Imports>>=
(rnrs unicode)
@

<<Field Parsing>>=
(define-parser rfc2822-parser:optional-field
	(*parser [field-name rfc2822-parser:field-name]
					 [(parser:char= #\:)]
					 [contents rfc2822-parser:unstructured]
					 [rfc2822-parser:crlf]
		(parser:return 
			(cons (string->symbol (string-downcase field-name))
				contents))))

(define-parser rfc2822-parser:field-name
	(parser:string:at-least 1 rfc2822-parser:ftext))

(define-parser rfc2822-parser:ftext
	(parser:char-in-set
		(char-set-difference char-set:full
			char-set:iso-control
			(char-set #\nul #\space #\:))))

@

\subsection{Obsolete Optional Fields (4.5.8)}

<<Obsolete>>=
(define-parser obs-optional
	(*parser [name rfc2822-parser:field-name]
					 [(parser:string:repeated rfc2822-parser:wsp)]
					 [(parser:char= #\:)]
					 [val rfc2822-parser:unstructured]
		(parser:return (cons name val))))

@

\chapter{Licensing}

This library is distributed under an ISC License.

<<License>>=
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; RFC 2822 Parsing for Scheme
;;; Version 1
;;; 
;;; Copyright (c) 2009 Aaron W. Hsu <arcfide@sacrideo.us>
;;; 
;;; Permission to use, copy, modify, and distribute this software for
;;; any purpose with or without fee is hereby granted, provided that the
;;; above copyright notice and this permission notice appear in all
;;; copies.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
;;; WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
;;; WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
;;; AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
;;; DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
;;; OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
;;; TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
;;; PERFORMANCE OF THIS SOFTWARE.
@

\chapter{Loading and file dependencies}

For those who wish to wrap this code in their own module systems, 
the following chunk is provided.

<<rfc2822-plain.scm>>=
<<Datatypes>>

<<Utilities>>

<<Tokenization>>

<<Field Parsing>>

<<Message Parsing>>

<<Obsolete>>
@
