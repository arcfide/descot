\title{Variable Swapping}

\chapter{Introduction}

It should not take tremendous effort to swap the values of two variables 
or two elements in some data structure. 
The following code makes it very easy to swap things in Scheme.

\chapter{Swapping in Scheme}

\procsig{[[swap-values!]]}
  {\var{set-proc} \var{object1} \var{object2}}{} 
\procsig{[[swap-values!]]}
  {\var{ref-proc} \var{set-proc} \var{object1} \var{object2}}{}
\procsig{[[swap-values!]]}
  {\var{ref-proc} \var{set-proc} \var{object} \var{index1} \var{index2}}{}
\procsig{[[swap-values!]]}
  {\var{ref-proc} \var{set-proc} \var{object} \var{index1} 
    \var{index2} \var{ref-args}}{}
\procsig{[[swap-values!]]}
  {\var{ref-proc} \var{set-proc} \var{object} 
    \var{index1} \var{index2} \var{ref-args} \var{set-args}}{}

This procedure swaps values in objects, but does not change bindings. 
That is, it can be used to do object-mutation based swapping. The above 
incantations specify differing levels of specificity for passing 
arguments to ref-proc and set-proc.  

<<Code>>=
(define swap-values!
  (case-lambda
    [(set! obj1 obj2)
     (let ([x obj1])
       (set! obj1 obj2)
       (set! obj2 x))]
    [(ref set! obj1 obj2)
     (let ([x (ref obj1)])
       (set! obj1 (ref obj2))
       (set! obj2 x))]
    [(ref set! obj i j)
     (let ([x (ref obj i)])
       (set! obj i (ref obj j))
       (set! obj j x))]
    [(ref set! obj i j ref-args)
     (let ([x (apply ref `(,obj ,i ,@ref-args))])
       (set! obj i (apply ref `(,obj ,j ,@ref-args)))
       (set! obj j x))]
    [(ref set! obj i j ref-args set-args)
     (let ([x (apply ref `(,obj ,i ,@ref-args))])
       (apply set! `(,obj ,i ,(apply ref `(,obj ,j ,@ref-args)) ,@set-args))
       (apply set! `(,obj ,j ,x ,@set-args)))]))

@


\procsig{[[swap-names!]]}{\var{binding1} \var{binding2}{}

This form is a convenience wrapper for swapping the values of two bindings.

<<Code>>=
(define-syntax swap-names!
  (syntax-rules ()
    [(_ x y)
     (let ([z x])
       (set! x y)
       (set! y z))]))

@

\procsig{[[swap!]]}{\var{swap-names!} $\cup$ \var{swap-values!}}{}

This convenience form can be used 
to do both binding and object based mutations 
for swapping elements.  
It uses the above form  and procedure. 

<<Code>>=
(define-syntax swap!
  (syntax-rules ()
    [(_ x y)
     (swap-names! x y)]
    [(_ x1 x2 x3 ...)
     (swap-values! x1 x2 x3 ...)]))

@

\chapter{R6RS Form}

<<swap.sls>>=
<<License>>

(library (arcfide swap)
  (export swap! swap-values! swap-names!)
  (import (rnrs base) (rnrs control))

<<Code>>

)
@

\chapter{Chez Module Form}

<<swap.ss>>=
<<License>>

<module swapping
  (swap-values! swap-names! (swap! swap-values!))
  (import scheme)

<<Code>>

)

\chapter{Vanilla Source Files}

<<swap.scm>>=
<<License>>

<<Code>>
@

\chapter{License}

This code is distributed under an ISC License.

<<License>>=
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Convenience functions for swapping values
;;; 
;;; Copyright (c) 2009 Aaron Hsu <arcfide@sacrideo.us>
;;; 
;;; Permission to use, copy, modify, and distribute this software for
;;; any purpose with or without fee is hereby granted, provided that the
;;; above copyright notice and this permission notice appear in all
;;; copies.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
;;; WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
;;; WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
;;; AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
;;; DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
;;; OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
;;; TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
;;; PERFORMANCE OF THIS SOFTWARE.
@
