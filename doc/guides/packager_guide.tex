\input docmac

\title{Guide to Packaging with Descot}
\author{Shu Zhou and Aaron W. Hsu}
\contact{[shuzhou,awhsu]@indiana.edu}

\maketitlepage

\abstract
The Descot packager is designed to improve the portability and visibility 
of code that is distributed
by Scheme programmers. 
Rather than define code using a specific module 
system with a specific system dependency or layout
that must be individually translated, into either other module 
systems or into Descot metadata, the Descot packager provides an easy 
to write encoding of the core vocabulary in the Descot metalanguage in 
an extensible format. Instead of writing SRDF files for each file, 
you can define a series of package files that describe your code,
and this can be used as a common base for a variety of uses. 
A library author or collector can generate a single SRDF file suitable
for uploading to a Descot repository, making it easy to publish the
information about a library.
Someone who has downloaded the library and wishes to use it in a
possibly unique or special environment can generate modules for a
specific Scheme implementation from the package files, and can use a
package manager to install or configure the package appropriately.
This Guide introduces Descot and the problems it solves in the
Introduction, and then moves on with a tutorial about using the
packager. Following that the details of how to use the system and its
features are described. User's who wish to gain a more technical,
implementator's perspective on the program should consider the woven
source code as their best resource.
\endabstract
 
\chapter{Introduction}{}%

\section{Ben and Amy}{}%
We will use the names Ben and eAmy to represent two different kinds 
of users. Ben represents the users who write code and Amy represents
the normal users who want use the code written by code writers like
Ben.

\section{Ben's Problem}{}%
Ben's problem is to let normal users to use his code. But usually 
normal users could use the code written by code writters like Ben 
directly, instead they should have an more easy and understandable
way for using it. So it is the problem for Ben to solve.

\section{Amy's Problem}{}%
Amy's problem is that she wants to use the code written by packager 
writters like Ben. But she may not have same modules, compilers, 
libraries as Ben's, so the problem exists how to use the code generated
by Ben or other packager writers with different environment mentioned 
above.

\section{Using Descot to Solve the Problem}{}%
Descot could solve the problem mentioned above for Ben and Amy. The 
following is how it works: Ben should write SRDF file by hand which 
is a really complicated job and then send it to descot server or send
it directly to Amy. For Amy, she will download the file in descot 
server or accept the file directly sent to her. And once receive the 
SRDF file, she has to write S2M or someone else has to which is used 
for format convertion, like change SRDF format to R6RS module or some 
other format the user wants. This is the whole process how descot 
solves the problem for packager writers and normal users who want to 
use code.

\section{Using the Packager to make it easier}{}%
Under this situation, the Descot Packager is provided so the problem
mentioned above will be more easily to solve. Now people like Ben has 
no need to write SRDF file by hand any more, instead he should write 
Packager file instead of SRDF file and relatively it is a easier job 
and Packager file could change the code to SRDF file for him. From the
normal users perspective, the S2M is already included in Packager 
document so no need for users like Amy write S2M by hand any more. So 
with Descot Packager, the whole thing will become much more easy to 
solve.

\section{Benefits}{}%
\section{How to use this guide}{}%
\chapter{Tutorial}{}%
\section{Our Example Library}{}%
\section{Creating the Package files}{}%
\section{Generating SRDF}{}%
\section{Generating Implementation Modules}{}%
\chapter{Packager Programs}{}%
\section{{\tt descot-packager}}{}%
First is Descot Packager Main Program.The packager program
defined here processes the input files and generates output to standard
output of the given type specified by <output-type>. At least the 
output-type SRDF is supported. Additional modules supporting different 
output types can be loaded dynamically based on what is available.
packager: <output-type> <input-file> ...

Then is Validating Input. We should make sure that each package
file can be loaded and that the module is a valid one.The following is 
explanation of validate command line, first have to make sure at least 
one argument exists so it means at least there is an ouput file. And then
there is need to check the input file at last to check whether it is srdf
file or existed module.

The third part is Loading the output processors. If the output type specified
is not a derivative of SRDF, then it assumes that it is the name of a module
that is available in the module-path directory. And here the module path is 
determined by checking for the DSCTPKGRMODPATH environment variable. Loading 
such a module should define a single procedure converter that, given an SRDF
expression list, prints the results to standard output.

Next one is for making sure that the input files is under correct order.
The general process is like this: to process each package file,it should 
be loaded with the appropriate evaluation procedure, which takes the form, 
evals it through the (arcfide descot packager language) environment,and 
then runs the converter on it.

The last part is Utilities for Output types. It means that there is need
to check whether the module exists and provide a means for setting the 
module path. And the module path is determined by checking for the 
DSCTPKGRMODPTH environment variable, which should point to a directory that
contains all of the Descot Packager modules for the output types.

\section{{\tt srdf2module}}{}%
\chapter{Packager File Format}{}%
Descot Packager is a utility to assist in the creation and use of Descot
stores. It is intended to be used as an easier packaging format for 
programmers who write libraries. After writing the code for the library,
the programmer can write a Descot package description, which can be 
then turned into an SRDF file for submission to Descot repositories, 
or, it can be used to generate implementation specific Module declarations.
It contains the Descot Package Language, Class Definitions, Constructing 
Subject URIs, Properties, Grounding/resolving relative references, Typed 
Properties, Descot Property Definitions and Descot Node URIs.

\section{Syntax}{}%
For the Descot Package Language, it is an encoding of a specific RDF
based language in prefix notation. It allows for easier and more natural 
construction of Descot stores without having to do all of the heavy syntax 
work that SRDF, XML, or Turtle would require.Essentially, to build a Descot 
Package file is to define a graph by specifying the association or edges 
associated between a given subject and a series of objects. That is, a Descot 
package file consists of global definitions and node forms. These node forms 
associate a particular subject of a given type with zero or more properties. 
So, a package file consists of a series of thefollowing forms:
<definition>
(node <subject> : <class> <property> ...)
The combination of all
of these associations forms a graph of the various nodes and edges given 
in the file(s). The output of these files is SRDF code, and these forms 
can be thought of as a syntactic wrapping around SRDF. That is, they have 
rather direct mappings to SRDF equivalents, provided that allow for
the specfic syntactic limitations imposed by each. They are not as general 
as SRDF forms.
However, since these forms simply represent a special Scheme evaluation 
environment that can be used to build an SRDF expression list, it is also 
reasonable for allowing that SRDF can be listed in any place where you 
can place a raw Scheme value and have it interpreted. This would be at the 
top level and anywhere that is escaped by an escape form. The quoted SRDF datum
may then be given directly, instead of relying on the specfic syntactic forms 
given here. This allows using the syntactic forms whenever possible, but
allows breaking this form and use SRDF when necessary.
For Class Definitions, whenver create a new node in a Descot graph, the node is 
almost certainly associate with some particular class. Each class 
provides information to nodes about how they should behave and what valid 
properties can be used. Within the Packager language, these nodes are used 
to provide roots and property defaults for resolving node names and 
inserting properties for each class of nodes.At the moment, classes are used 
only to resolve the subjects and fill in default properties. It could also be 
used to do error checking on the properties, but this is not implemented yet.
The Descot metalanguage defines the following classes:Library;Binding;License;
Person;Retrieval-method;Archive;Single-file;SCM;CVS;Implementation.For each 
class, subject root and default properties parameters are provided, which establish 
the defaults for the class, as well as the class type, which is used to automatically 
insert the correct type annotation on the class subject. Subjects, if relative, 
will use the subject root parameter to fully ground their locations, and
the default properties will be added to this class, and can be defined globally.
Plus, a default-root property that can be used as a fallback since even though a 
root parameter for every class is defined, it's likely that some of these default root
parameters will not be defined. The subject root parameter contain a string that is 
the default base root for any relatively defined subject with the given 
class.The default properties parameter is bound in the prelude file to 
any properties true that hold for all subjects of a particular class.
There are procedures enforce the naming conventions, with these procedures, 
each of the classes could then be trivially defined. However, all of the
classes have a similar naming convention, so to enforce this, a bulk class 
definition syntax should be used. Basically, each class should be a 
capitalized term, which forms the prefix for the two parameters, namely, 
root and default-properties. Each should be prfixed with the Class-. 
Finally, it is assumed that each class definition has a node name defined 
by (dscts "Class") which is the type of the class in RDF.
The following is a nice looking set of classes definition.
(define-classes Library Binding Syntax License Person
Retrieval-method Archive Single-file SCM CVS Implementation).
For Constructing Subject URIs, when a node form is used, the subject 
may be in either a string, symbol,or list form. In the latter two forms, 
the object or subject is considered to be a relative reference. This
means that it must be converted to a URI path and then appended to the 
base URI. A string reference is expected to be an absolute reference.

\section{Vocabulary}{}%
\section{Escapes}{}%
\chapter{RDF Primer}{}%
\section{What is RDF?}{}%
\section{How Descot uses RDF}{}%
\section{How Packages map to RDF Graphs}{}%
\section{Dealing with namespaces}{}%

\chapter{Programme}{}%
For the first part Program, it contains two subparts. The first subpart 
is mainly about transformation from code to metadata and the second 
part is focused on metadata to code.
The Descot Package language is defined as the code is written here, 
but at a high-level, it consists of forms for defining Class objects, 
properties, and objects. Any given node or object is either a string 
or a list form, or, as a special case, a symbol is considered to be a 
shorthand for a list form of one element. The list form is a relative 
reference, while a string form is considered an absolute reference. 
Properties are designed to be used in the tails of Class forms, and 
associate given classes propert with some object/node. Class forms
associate a single object (subject) with a set of properties.

\medskip
\verbatim
(Library (arcfide chezweb tangle)
(author (arcfide))
(license isc-license)
(exports tangle me silly)
(location
(Gopher _
(uri "gopher://gopher.sacrideo.us/9chezweb/cheztangle.ss"))))
|endverbatim
\medskip

Class Definitions. The Descot metalanguage defines the following classes:

\unorderedlist
\li Library
\li Binding
\li License
\li Person
\li Retrieval-method
\li Archive
\li Single-file
\li SCM
\li CVS
\li Implementation
\endunorderedlist

\noindent
The Descot packager defines class forms for each of these. They all share a common form.

\medskip
\verbatim
(<class-name> <subject> <property> ...)
|endverbatim
\medskip

\noindent
This allows for a fairly straightforward definition for classes. 
For each class, we provide subject root and default properties parameters,
which establish the defaults for the class, as well as the class type, 
which is used to automatically insert the correct type annotation on the 
class subject. Subjects, if relative, will use the subject root parameter 
to fully ground their locations, and the default properties will be added 
to this class, and can be defined globally.

The subject root parameter should contain a string that is the 
default base root for any relatively defined subject with the given class.

\medskip
\verbatim
Define subject root parameter ¡Ô          
(define subject-root
(make-parameter
(default-root)
(lambda (x)
(unless (string? x)
(errorf ¡¯subject-root "expected a URI string, found ~s" x))
x)))
|endverbatim
\medskip

\noindent
The default properties parameter should be bound in the prelude file to 
any properties true that hold for all subjects of a particular class.

\medskip
\verbatim
Define default properties parameter ¡Ô  
(define default-properties
(make-parameter
¡¯()
(lambda (x)
(unless (or (null? x) (pair? x))
(errorf ¡¯default-properties
"Expected a list of properties, found ~s"
x))
x)))
|endverbatim
\medskip

\noindent When a class form is used, the subject may be in either a string, 
symbol, or list form. In the latter two forms, the object or subject is 
considered to be a relative reference. This means that it must be converted 
to a URI path and then appended to the base URI. A string reference is expected 
to be an absolute reference.

\medskip
\verbatim
Construct subject ¡Ô
(cond
[(string? subject) subject]
[(pair? subject)
(format "~a~~a~^/~" (subject-root) subject)]
[(symbol? subject) (format "~a~a" (subject-root) subject)]
[else
(errorf ¡¯name
"expected a string, list, or symbol, but found ~s"
subject)])
|endverbatim
\medskip

The following procedures enforce the naming conventions mentioned 
in the Package Syntax section.

\medskip
\verbatim
¡Ô       
(meta define (class-parameter class)
(datum->syntax
class
(string->symbol (format "~a-root" (syntax->datum class)))))
(meta define (class-default-properties class)
(datum->syntax
class
(string->symbol
(format "~a-default-properties" (syntax->datum class)))))
(meta define (class-type class)
(datum->syntax
class
(string->symbol (format "dscts:~a" (syntax->datum class)))))
|endverbatim
\medskip

\noindent Properties accept as their arguments forms which are meant 
to indicate the type of object associated with a given property. 
At the root, a property establishes some property associate with the 
object created from its arguments:

\medskip
\verbatim
(<property> <object> ...)
|endverbatim
\noindent The |property| will be some URI, and the object will be some proper object list.
Properties will usually have to ground their relativeobject references in some way or another based on some root URI. 
|endverbatim
\medskip

\medskip
\verbatim
<*>¡Ô     
(define (resolve root relative)
(assert (string? root))
(assert
(or (string? relative) (pair? relative) (symbol? relative)))
(cond
[(string? relative) (string-append root relative)]
[(pair? relative) (format "~a~~a~^/~" root relative)] 
[(symbol? relative) (format "~a~a" root relative)]))
|endverbatim
\medskip

\section{Typed Properties}
While using |define-property| by itself is okay, there are a number of 
common idioms for properties that show up, so rather than writing each 
of these repeatedly, some of these patterns are defined(See Syntax 
Section).

\section{Descot Property Definitions}
Descot Property Definitions. The following are the defined properties for Descot.

\medskip\verbatim
<*>¡Ô
(define-string-property name dscts:name)
(define-node-property alternatives dscts:alts default-root)
(define-string-property description dscts:desc)
(define-node-property homepage dscts:homepage default-root)
(define-node-list-property import dscts:deps Library-root)
(define-string-list-property alternative-names dscts:names)
(define-node-list-property
export
dscts:exports
Binding-root)
(define-node-property license dscts:license License-root)
(define-node-list-property
authors
dscts:authors
Person-root)
(define-date-property creation dscts:creation)
(define-date-property modified dscts:modified)
(define-node-property contact dscts:contact Person-root)
(define-node-property
implementation
dscts:implementation
Implementation-root)
(define-string-property version dscts:version)
(define-node-property
location
dscts:location
Retrieval-method-root)
(define-string-list-property categories dscts:categories)
(define-year-property copyright-year dscts:copyright-year)
(define-node-property
copyright-owner
dscts:copyright-owner
Person-root)
(define-string-property email dscts:email)
(define-string-property url dscts:url)
(define-string-property cvs-root dscts:cvs-root)
(define-string-property cvs-module dscts:cvs-module)
|endverbatim
\medskip

\chapter{Package Organization}{}%

\section{Dictorary Layout}{}%
\medskip\verbatim
(?what commond should I put here?) packages/
		drc/
			packages_guide.tex
			packages_tech.tex
		packages.w
|endverbatim
\medskip

Under packages directory is drc directory that includes 
packages\_guide.tex file and packages\_tech.tex file.

\section{Prelude}{}%
(?what commond should I put here?)
 For defining some basic defaults(?) for a set of files.

\section{Library Package}{}%
(?what commond should I put here?)
Library Definition: (arcfide descot packager environment)
A library that will form the execution environment of our Descot packages is defined.
Exports: Library Binding License Person Retrieval-method Archive Single-file SCM CVS Implementation
Imports: (chezscheme)

\chapter{Package Syntax}{}%
The following are some examples of syntaxes of package language.

\medskip\verbatim
<*>¡Ô                                                     
(define-syntax define-class
(syntax-rules ()
[(_ name subject-root default-properties class-type)
(begin
< Define subject root parameter >
< Define default properties parameter >
(... (define-syntax name
(syntax-rules ()
[(_ subject property ...)
¡®(,< Construct subject > (type class-type) property
... . ,(default-properties))]))))]))
|endverbatim
\medskip

Then trivially define each of the classes. However, all of the classes 
have a similar naming convention, so to enforce this, the following 
bulk class definition syntax should be used. Basically, each class 
should be a capitalized term, which forms the prefix for the two 
parameters,namely, root and default-properties. Each should be prefixed 
with the Class-. Finally,each class definition is assumed to have a 
node name defined by dscts:Class which is the type of the class in RDF.

\medskip\verbatim
<*>¡Ô
(define-syntax define-classes
(lambda (x)
(syntax-case x ()
[(_ class)
(with-syntax ([param (class-parameter #¡¯class)]
[def-prop (class-default-properties #¡¯class)]
[type (class-type #¡¯class)])
#¡¯(define-class class param def-prop type))]
[(_ class classes ...)
(with-syntax ([param (class-parameter #¡¯class)]
[def-prop (class-default-properties #¡¯class)]
[type (class-type #¡¯class)])
#¡¯(begin
(define-class class param def-prop type)
(define-classes classes ...)))])))
|endverbatim
\medskip

Now a nice looking set of classes is defined that were mentioned in the ealier section.

<*>¡Ô 
(define-classes Library Binding Syntax License Person
Retrieval-method Archive Single-file SCM CVS Implementation)

In order to define a property, some syntax are being defined, which accepts some syntax for the arguments and then performs some transformation on it to build the object. Additionally, the property's URI are provided.
 
\medskip\verbatim
<*>¡Ô
(define-syntax define-property
(syntax-rules ()
[(_ name uri clause ...)
(define-syntax name
(property-syntax-rules uri () clause ...))]))
The property-syntax-rules macro makes sure to check the input clause forms, which should be one of the following forms:
((e ...) test? body)
((e ...) body)
It then creates a syntax-rules form of the following shape:
(syntax-rules ()
[(_ e ...) test? ¡®(,uri . ,body)] ...)

<*>¡Ô 
(define-syntax property-syntax-rules
((_ uri (((e ...) pass? body) ...))
(syntax-rules () [(_ e ...) pass? ¡®(,uri . ,body)] ...))
((_ uri (checked ...) ((e ...) test? body) rest ...)
(property-syntax-rules
uri
(checked ... ((e ...) test? body))
rest
...))
((_ uri (checked ...) ((e ...) body) rest ...)
(property-syntax-rules
uri
(checked ... ((e ...) #t body))
rest
...)))
|endverbatim
\medskip

The following syntaxes are mentioned in the of Programme part.
|define-string-property| defines a property that expects a single string argument as the object. 

\medskip\verbatim
<*>¡Ô                  
(define-syntax define-string-property
(syntax-rules ()
[(_ name uri)
(define-property name
uri
((s) (string? (syntax->datum #¡¯s))
¡®^ ,s ,(xsd "dateTime"))))]))
|endverbatim
\medskip

|define-date-property|defines a property that expects a single date string in a standard RDF dateTime format. 

\medskip\verbatim
<*>¡Ô                             
(define-syntax define-date-property
(syntax-rules ()
[(_ name uri)
(define-property name
uri
((s) (string? (syntax->datum #¡¯s))
¡®(^ ,s ,(xsd "dateTime"))))]))
|endverbatim
\medskip

A special case of the date format is the Year format, and so define 
define-year-property to handle cases that expect the year.

\medskip\verbatim
<*>¡Ô     
(define-syntax define-year-property
(syntax-rules ()
[(_ name uri)
(define-property name
uri
((y) (integer? (syntax->datum #¡¯y))
¡®(^ ,(number->string y) ,(xsd "gYear"))))]))
|endverbatim
\medskip

|define-node-proprety| defines a proprety that expects a single node. 

\medskip\verbatim
<*>¡Ô                
(define-syntax define-node-property
(syntax-rules ()
[(_ name uri root)
(define-property name
uri
((n) (let ([x (syntax->datum #¡¯n)])
(or (string? x) (pair? x) (symbol? x)))
(resolve root n)))]))
|endverbatim
\medskip

|define-list-property| defines a property that expects some list of 
objects of a certain, specified type. The programmer provides a 
predicate and a creator that creates the right objects from the input.

\medskip\verbatim
<*>¡Ô          
(deifne-syntax
define-list-property
(syntax-rules ()
[(_ name uri test? make)
(define-property name
uri
((e1 e2 ...)
(for-all test? #¡¯(e1 e2 ...))
¡®(,(make e1) ,(make e2) ...)))]))
|endverbatim
\medskip

|define-node-list-property| defines a property that expexts a list of 
nodes as its objects.

\medskip\verbatim
<*>¡Ô  
(define-syntax define-node-list-property
(syntax-rules ()
[(_ name uri root)
(define-list-property
name
uri
(lambda (x)
(let ([x (syntax->datum x)])
(or (string? x) (pair? x) (symbol? x))))
(lambda (x) (resolve root x)))]))
|endverbatim
\medskip

|define-string-list-proprety| defines a property that expects one or 
more strings as objects.

\medskip\verbatim
<*>¡Ô  
(define-syntax define-string-list-property
(syntax-rules ()
[(_ name uri)
(define-list-property
name
uri
(lambda (x) (string? (syntax->datum x)))
(lambda (x) '($ ,x)))])) 
|endverbatim
\medskip

\chapter{RDF Crash Course}{}%
This package is used for teaching users the knowledge about RDF in an 
easy-understand and easy-master way. Teach the essentail points of RDF 
to let normal users to pick it up quickly.

\medskip{\narrower\noindent
This is a quote from someone famous. This is a quote from someone
famous. This is a quote from someone famous. This is a quote from
someone famous. This is a quote from someone famous. This is a quote
from someone famous. This is a quote from someone famous. This is a
quote from someone famous.\par}\medskip

\noindent This is the next paragraph.

\medskip\verbatim
$ tex sample_doc.tex
And it obeys indenting and ignores \funny things.
|endverbatim

\section{Subbed Section}{sec-sub-samp}%
\subsection{Real Subsection}{sub-sec-samp}%
This would contain the contents of the sub section.

You could also put a graphic somewhere in here.

\medskip\verbatim
How could I insert a graph?
Where should I write the name of the file?
|endverbatim
\medskip

\bye
